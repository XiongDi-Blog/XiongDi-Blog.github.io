<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程基础（二）-线程的命名</title>
      <link href="/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/"/>
      <url>/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在java中，每个线程都有自己的名字，在构建线程时为其取一个有意义的名字是一种比较好的做法，特别是在线程特别多的程序中，这样方便问题的排查和跟踪。</p><h2 id="1、线程的默认命名"><a href="#1、线程的默认命名" class="headerlink" title="1、线程的默认命名"></a>1、线程的默认命名</h2><p>如果没有显示的为线程指定一个名字，线程会有一个以”Thread-“为前缀，以一个自增的数字为后缀的名字。这个自增的数字在整个jvm中不断自增,如果我们执行以下代码将会看到线程默认命名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    IntStream.range(0, 5).boxed().map(i -&gt; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName())</span><br><span class="line">    )).forEach(Thread::start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">Thread-1</span><br><span class="line">Thread-4</span><br><span class="line">Thread-2</span><br><span class="line">Thread-3</span><br></pre></td></tr></table></figure><h2 id="2、使用构造方法命名线程"><a href="#2、使用构造方法命名线程" class="headerlink" title="2、使用构造方法命名线程"></a>2、使用构造方法命名线程</h2><p>java提供了很多Thread的构造方法，其中大部分可以对线程进行命名，具体如下:</p><ul><li>Thread(String name)</li><li>Thread(Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</li></ul><p>我们尝试用第二个构造方法对线程进行命名，并输出命名后线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadName &#123;</span><br><span class="line">    public final static String PREFIX &#x3D; &quot;FINE-&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IntStream.range(0, 5).boxed().map(ThreadName::createThread)</span><br><span class="line">                .forEach(Thread::start);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Thread createThread(final int intName) &#123;</span><br><span class="line">        return new Thread(</span><br><span class="line">                () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">                PREFIX + intName</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们对线程使用了新名字，以”FINE-“开头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FINE-0</span><br><span class="line">FINE-2</span><br><span class="line">FINE-1</span><br><span class="line">FINE-3</span><br><span class="line">FINE-4</span><br></pre></td></tr></table></figure><h2 id="3、修改线程的名字"><a href="#3、修改线程的名字" class="headerlink" title="3、修改线程的名字"></a>3、修改线程的名字</h2><p>不论你使用线程默认的名字，还是使用构造函数自定义了线程的名字，在启动线程之前，还有一次修改线程名字的机会，线程一旦启动，名字将不再被修改，可以使用线程的setName方法修改线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread namedThread &#x3D; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">        &quot;ConstructorName&quot;</span><br><span class="line">    );</span><br><span class="line">    namedThread.setName(&quot;SetName&quot;);</span><br><span class="line">    namedThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，最终线程的名字为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetName</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 线程命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在java进程中创建、启动线程并使用jconsole观察线程</title>
      <link href="/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在java中，创建线程主要有两种方式，一是通过继承Thread类，二是通过实现Runnable接口。但严格地说，在java JDK中，能够代表线程的只有Thread类，请大家思考Runnable接口又是如何运作的呢？我们将在后续揭晓。</p><h1 id="一、使用Thread类创建线程"><a href="#一、使用Thread类创建线程" class="headerlink" title="一、使用Thread类创建线程"></a>一、使用Thread类创建线程</h1><p>使用继承Thread类创建线程的方式非常简单，只需要继承Thread类，然后重写Thread类的run方法，在run方法中实现自己的业务逻辑即可，下面我们就来创建并运行一个java线程。</p><p>这个多线程程序模仿在看新闻的同时听听音乐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                playMusic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void playMusic()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;play music&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void readNews()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;read news&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序会不断的交替看新闻和听音乐，如果使用java8 Lambda表达式，代码看起来会更加简洁。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(Main::playMusic).start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-Thread模拟银行大厅的叫号系统"><a href="#1-1-Thread模拟银行大厅的叫号系统" class="headerlink" title="1.1 Thread模拟银行大厅的叫号系统"></a>1.1 Thread模拟银行大厅的叫号系统</h3><p>学习了使用Thread类创建线程，那我们使用Thread类来模拟一下银行大厅的叫号系统吧</p><p>相信很多人都去过银行办理业务吧，当你走进银行，需要先领取一张流水号纸票，然后拿着纸票在坐在休息区等待你的号码显示在业务办理的橱窗显示器上面，如下图所示:<br><img src="/img/thread/bank_stream.png" alt=""><br>假设银行大厅共有4台出号机，限定当天受理50笔业务，意味着号码最多只能出到50。<br>TicketProducer代表大厅的出号机，代码如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducer extends Thread &#123;</span><br><span class="line">    &#x2F;&#x2F; 柜台名称</span><br><span class="line">    public final String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    public TicketProducer(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(&quot;柜台：&quot; + name + &quot;当前受理号码是&quot; + index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写一个main函数对其进行测试，定义4个TicketProducer线程，并且分别行动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new TicketProducer(&quot;1号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;2号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;3号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;4号柜台&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后结果大失所望，怎么每个线程都是从1到50呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是1</span><br><span class="line">柜台：2号柜台当前受理号码是1</span><br><span class="line">柜台：1号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是2</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>出现这个问题，根本原因是每个线程的逻辑执行单元都不一样。创建了4个TicketProducer线程，他们的票号都是从1到50，并没有获取唯一一个递增的票号。那么应该怎么改进呢？很容易想到，无论初始化多少个TicketProducer线程，只需要保证index唯一即可，我们会立即想到使用static修饰index的方式，这样可以吗？让我们试试，改进后的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是3</span><br><span class="line">柜台：1号柜台当前受理号码是4</span><br><span class="line">柜台：2号柜台当前受理号码是5</span><br><span class="line">柜台：1号柜台当前受理号码是6</span><br><span class="line">柜台：3号柜台当前受理号码是7</span><br><span class="line">柜台：2号柜台当前受理号码是8</span><br><span class="line">柜台：1号柜台当前受理号码是9</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过对index进行static修饰，看起来满足了我们的需求，但共享资源被多个线程进行读写操作时很容易出现线程安全问题，这里的(index++)实际上对index变量进行了读、更改和写操作，所以当多尝试几次，便会出现多个线程处理同号纸票或者某些号不会出现甚至大于Max的情况。况且这里只有一个index共享资源，如果共享资源很多呢？不可能都用static修饰，而且static修饰的变量生命周期很长，所以java提供了一个接口Runnable专门用于处理该问题，将线程的控制和业务逻辑彻底分离开。（使用Runnable接口仍会有线程安全问题）</p><h1 id="二、使用Runnable接口创建线程"><a href="#二、使用Runnable接口创建线程" class="headerlink" title="二、使用Runnable接口创建线程"></a>二、使用Runnable接口创建线程</h1><p>我们说使用static修饰index这个共享资源不是一个好方式，那么我们使用Runnable接口实现逻辑执行单元，重构一下银行大厅叫号系统吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducerRunnable implements Runnable &#123;</span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数,不做static修饰</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; 的号码是&quot; + index++);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始行动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TicketProducerRunnable ticketProducerRunnable &#x3D; new TicketProducerRunnable();</span><br><span class="line"></span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;1号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;2号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;3号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;4号柜台&quot;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序输出和使用static修饰index效果是一样的，仍然会有线程安全问题，因为他们的资源都是共享的，但不会再出现每一个叫号机从1打印到50的情况，而且变量的生命周期可以随线程的结束而结束。</p><h1 id="三、使用Jconsole观察线程"><a href="#三、使用Jconsole观察线程" class="headerlink" title="三、使用Jconsole观察线程"></a>三、使用Jconsole观察线程</h1><p>从java5开始，JDK中引入了Jconsole以观察线程，进行性能分析。让我们来试试使用Jconsole观察一下我们程序的线程有多少个吧。</p><h3 id="3-1-启动Jconsole"><a href="#3-1-启动Jconsole" class="headerlink" title="3.1 启动Jconsole"></a>3.1 启动Jconsole</h3><p>找到JDK安装路径的bin目录，双击运行jconsole.exe<br><img src="/img/thread/jconsole_start.png" alt=""><br>选择我们要查看的本地线程，这里是TicketProducerRunnable<br><img src="/img/thread/jconsole_thread.png" alt=""><br>可以看到除了我们创建的1号、2号、3号、4号线程外，还有其他线程，这是jvm启动时创建的许多线程。<br>同样可以使用性能分析工具jstack观察线程，jstack可以分析线程的堆栈使用情况，后续会做详细解释。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> Runnable </tag>
            
            <tag> Jconsole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（一）--认识线程</title>
      <link href="/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;想必大家都有过这样的体验，在聊天的时候听听音乐，在创作的时候查查资料，这就是我们常说的并行。在计算机的世界里，并行实际上是指，一系列任务在计算机中同时运行。在单核CPU中并没有真正的并行，它只不过是CPU时间钟带给你的错觉。但在多核CPU计算机中，真正的并行还是存在的。</p><h1 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h1><p>&ensp;&ensp;&ensp;&ensp;如今的操作系统大多都支持多任务的执行，对于计算机而言，一个任务就是一个进程(Process),在每一个进程内部至少要有一个线程(Thread)是在运行中，有时线程也称为轻量级进程。<br>&ensp;&ensp;&ensp;&ensp;线程是程序执行的最小单元，每个线程都有自己的局部变量表，程序计数器（指向正在执行的指令指针）以及各自的生命周期。<br>&ensp;&ensp;&ensp;&ensp;那么在java中如何创建线程呢，如果你还不太清楚可以看我另外一篇文章<a href="https://xiongdi-blog.github.io/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/">在java进程中创建线程并使用jconsole观察线程</a></p><h1 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a>二、线程的生命周期</h1><p>&ensp;&ensp;&ensp;&ensp;前面提到过，每个线程都有自己的局部变量表，程序计数器和生命周期。线程的生命周期描述了线程从创建到死亡的过程。<br>&ensp;&ensp;&ensp;&ensp;请大家思考，执行了线程的start方法就代表该线程开始执行了吗？<br><img src="/img/thread/thread_life.png" alt=""><br>&ensp;&ensp;&ensp;&ensp;由上图可知：线程的生命周期大体分为五个阶段</p><ul><li>NEW：创建</li><li>RUNNABLE: 可执行状态</li><li>RUNNING：执行状态</li><li>BLOCKED：阻塞状态</li><li>TERMINALTED：结束状态</li></ul><p>&ensp;&ensp;&ensp;&ensp;线程从NEW切换为RUNNABLE只需要程序执行start方法，线程一经启动就可以立即得到执行吗？答案是否定的，线程的运行与否和进程一样都要听命于CPU的调度。</p><ul><li>当RUNNABLE状态的线程被cpu选中，从而进入了RUNNING状态</li><li>当RUNNING状态的线程由于CPU的调度轮询放弃执行、或者线程主动调用yield方法放弃CPU执行权。线程进入RUNNABLE状态</li><li>当RUNNING状态的线程调用wait、sleep或获取锁资源时，线程进入BLOCKED状态</li><li>当BLOCKED状态的线程被其他线程调用notify/notifyall唤醒、获取到了某个锁资源、、完成了指定时间的休眠或在阻塞过程中被其他线程调用interrupt方法打断，线程进入RUNNABLE状态</li><li>当线程调用了JDK已经不推荐使用的stop方法，意外死亡（JVM Crash），或者正常结束，线程直接进入TERMINALTED状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初遇SpringBoot</title>
      <link href="/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/"/>
      <url>/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="初遇SpringBoot"><a href="#初遇SpringBoot" class="headerlink" title="初遇SpringBoot"></a>初遇SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot是一个简化Spring开发的框架。用来监护spring应用开发，约定大于配置，去繁就简，just run 就能创建一个独立的，产品级的应用。</p><p>我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><h3 id="快速创建"><a href="#快速创建" class="headerlink" title="快速创建"></a>快速创建</h3></li></ol><ol start="2"><li><h3 id="独立运行"><a href="#独立运行" class="headerlink" title="独立运行"></a>独立运行</h3><ul><li>使用启动类快速启动，创建SpringBoot项目时会自动生成启动类。</li></ul></li><li><h3 id="主流框架集成"><a href="#主流框架集成" class="headerlink" title="主流框架集成"></a>主流框架集成</h3></li></ol><ol start="4"><li><h3 id="内嵌Servlet-可直接JAR运行"><a href="#内嵌Servlet-可直接JAR运行" class="headerlink" title="内嵌Servlet,可直接JAR运行"></a>内嵌Servlet,可直接JAR运行</h3></li></ol><ol start="5"><li><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3></li></ol><ol start="6"><li><h3 id="开箱即用，不需要配置繁琐的XML"><a href="#开箱即用，不需要配置繁琐的XML" class="headerlink" title="开箱即用，不需要配置繁琐的XML"></a>开箱即用，不需要配置繁琐的XML</h3></li></ol><ol start="7"><li><h3 id="环境区分"><a href="#环境区分" class="headerlink" title="环境区分"></a>环境区分</h3></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown使用指南</title>
      <link href="/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown的六级标题"><a href="#markdown的六级标题" class="headerlink" title="markdown的六级标题"></a>markdown的六级标题</h1><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- 文本1+ 文本2* 文本3</code></pre><p>效果：</p><ul><li>文本1</li></ul><ul><li>文本2</li></ul><ul><li>文本3</li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><pre><code>1. 列表内容2. 列表内容3. 列表内容</code></pre><p>效果：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><pre><code>---***</code></pre><p>效果：</p><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><pre><code>[简书](http://www.jianshu.com)</code></pre><p>效果：</p><p><a href="http://www.jianshu.com" target="_blank" rel="noopener">简书</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><pre><code>&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。</code></pre><p>效果：</p><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</p></blockquote><h1 id="斜体、粗体及斜体加粗"><a href="#斜体、粗体及斜体加粗" class="headerlink" title="斜体、粗体及斜体加粗"></a>斜体、粗体及斜体加粗</h1><pre><code>*一盏灯*， 一片昏黄；**一简书**， ***一杯淡茶***。</code></pre><p>效果：</p><p><em>一盏灯</em>， 一片昏黄；<strong>一简书</strong>， <strong><em>一杯淡茶</em></strong>。</p><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><pre><code>~~一盏灯， 一片昏黄； 一简书， 一杯淡茶。~~</code></pre><p>效果：</p><p><del>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</del></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>```<br>第一段代码<br>第二段代码<br>第三段代码<br>```<br>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段代码</span><br><span class="line">第二段代码</span><br><span class="line">第三段代码</span><br></pre></td></tr></table></figure><h1 id="句内代码块"><a href="#句内代码块" class="headerlink" title="句内代码块"></a>句内代码块</h1><pre><code>`create database hero;`</code></pre><p>效果：</p><p><code>create database hero;</code></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><pre><code>![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |</code></pre><p>效果：</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
