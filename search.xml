<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程进阶（一）-认识数据同步问题</title>
      <link href="/2020/01/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我们在追求多线程为程序带来更佳的效率的同时，也引入了共享资源安全的隐患。后续系列我们将探讨如何在安全的前提下高效地共享数据。</p><h3 id="1、什么是共享资源？什么是数据同步？"><a href="#1、什么是共享资源？什么是数据同步？" class="headerlink" title="1、什么是共享资源？什么是数据同步？"></a>1、什么是共享资源？什么是数据同步？</h3><p>共享资源是指能够被多个线程访问和操作（读写操作）的资源，而安全问题大多出现在多个线程同时对同一共享资源进行操作时，如何保证多个线程访问到的数据是一致的，则被称为数据同步或资源同步。</p><h3 id="2、数据不一致问题"><a href="#2、数据不一致问题" class="headerlink" title="2、数据不一致问题"></a>2、数据不一致问题</h3><p>当多个线程同时对共享资源进行读写操作，如我们要实现一个计数器，多个线程对其累加，代码如下:</p><pre><code>public class Task implements Runnable {    private Integer index = 1;    private final static Integer MAX = 500;    @Override    public void run() {        while (index &lt;= MAX) {            System.out.println(index++)        }    }    public static void main(String args[]) {        final Task task = new Task();        Thread thread1 = new Thread(task, &quot;thread1&quot;);        Thread thread2 = new Thread(task, &quot;thread2&quot;);    }}</code></pre><p>多次运行上诉代码会发现可能出现如下几种数据不一致的情况:</p><ul><li>某个值重复出现</li><li>某个值被跳过，没有出现</li><li>出现大于最大值500的数</li></ul><h3 id="3、数据不一致问题分析"><a href="#3、数据不一致问题分析" class="headerlink" title="3、数据不一致问题分析"></a>3、数据不一致问题分析</h3><h4 id="3、1-某个值重复出现"><a href="#3、1-某个值重复出现" class="headerlink" title="3、1 某个值重复出现"></a>3、1 某个值重复出现</h4><p>出现某个值重复的问题，是因为index++实际上包含了对index变量的读取和写入操作，假设线程1读取index为2，且没有将index+1的值写入时，线程2同时也读取了index为2，此时出现了两个相同值3。</p><h4 id="3-2-某个值被跳过，没有出现"><a href="#3-2-某个值被跳过，没有出现" class="headerlink" title="3.2 某个值被跳过，没有出现"></a>3.2 某个值被跳过，没有出现</h4><p>由于线程是由CPU按时间片调度执行的，假设线程1读取到了index=65，并将index+1写入，在线程1还未再次读取index打印到控制台时，CPU将执行权交给了线程2，此时线程2读取到index=66并输出67，这时CPU再将执行权交回线程1，线程1读取index=67并打印。</p><h4 id="3-3-出现大于最大值500的数"><a href="#3-3-出现大于最大值500的数" class="headerlink" title="3.3 出现大于最大值500的数"></a>3.3 出现大于最大值500的数</h4><p>在while判断时，当两个线程都读取到index=499，通过了判断，此时线程2短暂停顿，线程1将index累加到500，此时线程2恢复执行，导致输出结果为501。</p><p>上诉几个问题，均是多个线程同时操作共享资源引起的，那么我们应该怎么解决呢？将在后续文章中为大家解答。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 数据同步 </tag>
            
            <tag> 同步，线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（八）-线程join</title>
      <link href="/2020/01/10/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89-%E7%BA%BF%E7%A8%8Bjoin/"/>
      <url>/2020/01/10/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89-%E7%BA%BF%E7%A8%8Bjoin/</url>
      
        <content type="html"><![CDATA[<p>有很多时候，我们要执行的任务由多个子任务构成，需要等到每个子任务执行完成后才执行后续业务逻辑。也就是主任务等待子任务执行完成后再继续执行。</p><p>当然我们可以在单线程中一个一个的执行子任务，但效率会远远比不上多线程，为此java为这个需求提供了线程join方法。</p><p>在主线程A中join某个线程B，会使线程A进入等待，直到线程B的生命周期结束，或者达到给的的时间，在此期间A线程是处于BLOCKED状态的。</p><h3 id="1、Thread的三个不同的join方法"><a href="#1、Thread的三个不同的join方法" class="headerlink" title="1、Thread的三个不同的join方法"></a>1、Thread的三个不同的join方法</h3><ul><li>public final void join() throws InterruptedException</li><li>public final synchronized void join() throws InterruptedException</li><li>public final synchronized void join() throws InterruptedException</li></ul><p>与sleep一样，join方法也是一个可中断的方法，也就是说，如果有其他线程执行了对当前线程的interrupt操作，它也会捕获到中断信号。</p><h3 id="2、join方法的基本用法"><a href="#2、join方法的基本用法" class="headerlink" title="2、join方法的基本用法"></a>2、join方法的基本用法</h3><pre><code>public class ThreadJoin {    public static void main(String[] args) throws InterruptedException {        // 1、定义两个线程，并保存在threads中        List&lt;Thread&gt; threads = IntStream.range(1, 3)                .mapToObj(ThreadJoin::create)                .collect(Collectors.toList());        // 2、启动这两个线程        threads.forEach(Thread::start);        // 3、执行这两个线程的join方法        for (Thread thread: threads) {            thread.join();        }        System.out.println(&quot;子任务已执行完毕,我是主任务&quot;);    }    public static Thread create(int seq) {        return new Thread(() -&gt; {            System.out.println(Thread.currentThread().getName() + &quot;#执行子任务&quot;);            try {                TimeUnit.SECONDS.sleep(2);            } catch (InterruptedException e) {                e.printStackTrace();            }        }, String.valueOf(seq));    }}</code></pre><p>上述程序创建了两个线程、分别启动，并调用了这两个线程的join方法。（注意:join方法是主线程调用的，因此第一个线程还没有结束生命周期时，第二个线程的join方法不会得到执行，但是此时第二个线程已经启动了），运行上诉代码，你会发现两个子线程执行结束后，主线程才会执行输出语句。</p><h3 id="3、join方法实践"><a href="#3、join方法实践" class="headerlink" title="3、join方法实践"></a>3、join方法实践</h3><p>试想，你需要开发一款查询航班信息的APP，你的APP是没有这些实时数据的，当用户发起查询请求时，你需要到各大航空公司的接口获取信息，最后统计整理加工返回到客户端。当然JDK自带了很多高级工具，如CountDownLatch和CyclicBarrier等都可以完成类似功能，但仅我们目前所学的知识，join方法就可以完成该功能。</p><p>这个例子是典型的串行任务并行化处理，当用户在客户端输入出发地”上海”和目的地”广州”，服务器先验证用户信息，然后到各大航空公司的接口查询航班信息，然后统一加工返回给客户端。再细化到各大航空公司的接口，每个接口都不一样，返回的数据格式也不一样，查询速度也存在差异。如果串行的处理各个接口(逐个查询)，显然客户端将等待较长的时间，用户体验将会很差。如果我们将每个航空公司的接口查询都交给一个线程处理，然后在他们结束工作后统一对数据进行加工，将节省很多时间。下面我们就来设计这个程序。<br>首先我们定义一个获取数据的接口:</p><pre><code>public interface FightQuery {    List&lt;String&gt; get();}</code></pre><p>FightQuery提供了一个get方法，大家应该注意到了，不管是Thread的run方法，还是Runnable的run方法，都没有返回值，如果你想通过运行某个线程获取结果，那么你需要自己定义一个返回的接口。</p><p>FightQueryTask类是到各大航空公司获取数据的类:</p><pre><code>public class FightQueryTask extends Thread implements FightQuery {    private final List&lt;String&gt; fightlist = new ArrayList&lt;&gt;();    private final String from;    private final String to;    public FightQueryTask(String name, String from, String to) {        super(name);        this.from = from;        this.to = to;    }    @Override    public void run() {        try {            TimeUnit.SECONDS.sleep(2);            fightlist.add(Thread.currentThread().getName() + &quot;:航班&quot; + ThreadLocalRandom.current().nextInt(10) + &quot;#起点:&quot; + from + &quot;#终点:&quot; + to);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    @Override    public List&lt;String&gt; get() {        return this.fightlist;    }}</code></pre><p>OK，一切准备就绪，下面就来实现一下从”上海”到”广州”的查询吧！代码如下:</p><pre><code>public class FightQueryExample {    private static List&lt;String&gt; fightCompany = Arrays.asList(&quot;四川航空&quot;, &quot;上海航空&quot;, &quot;广州航空&quot;, &quot;南京航空&quot;, &quot;海南航空&quot;);    public static void main(String[] args) {        long start = System.currentTimeMillis();        List&lt;String&gt; result = search(&quot;上海&quot;, &quot;广州&quot;);        System.out.println(&quot;================Result================&quot;);        System.out.println(&quot;查询耗时:&quot;+ (System.currentTimeMillis() - start) / 1000 + &quot;秒&quot;);        result.forEach(System.out::println);    }    private static List&lt;String&gt; search(String from, String to) {        final List&lt;String&gt; result = new ArrayList&lt;&gt;();        // 创建查询航班信息的线程列表        List&lt;FightQueryTask&gt; tasks = fightCompany.stream()                .map(name -&gt; new FightQueryTask(name, from, to))                .collect(Collectors.toList());        // 分别启动这三个线程        tasks.forEach(Thread::start);        for (FightQueryTask task: tasks) {            try {                task.join();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        // 获取每个线程的查询结果，加入到result中        tasks.stream().map(FightQuery::get).forEach(result::addAll);        return result;    }}</code></pre><p>上诉程序输出结果如下:</p><pre><code>================Result================查询耗时:2秒四川航空:航班2#起点:上海#终点:广州上海航空:航班3#起点:上海#终点:广州广州航空:航班0#起点:上海#终点:广州南京航空:航班7#起点:上海#终点:广州海南航空:航班6#起点:上海#终点:广州</code></pre><p>我们查询每个航空公司接口的线程均用sleep休眠了2秒以假定每个接口查询耗时，如果使用串行方式逐个查询每个接口，查询上诉五个航空公司总耗时将为10秒，而使用join方法并行处理的总耗时为2秒。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> join </tag>
            
            <tag> 子任务 </tag>
            
            <tag> 串行任务 </tag>
            
            <tag> 并行化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（七）-线程interrupt及如何正确关闭线程</title>
      <link href="/2020/01/08/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89-%E7%BA%BF%E7%A8%8Binterrupt%E5%8F%8A%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/08/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89-%E7%BA%BF%E7%A8%8Binterrupt%E5%8F%8A%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程中断"><a href="#一、线程中断" class="headerlink" title="一、线程中断"></a>一、线程中断</h2><p>java的Thread类中提供了线程中断的方法，interrupt方法可以中断阻塞中的线程，让其继续运行，并抛出InterruptedException异常用于提示线程被中断。对Running状态的线程调用中断方法仅仅为其设置中断标识。</p><p>对于线程的中断，java提供了如下三种相关的方法:</p><ul><li>public void interrupt()</li><li>public static boolean interrupted()</li><li>public boolean isInterrupted()</li></ul><h3 id="1-1-interrupt"><a href="#1-1-interrupt" class="headerlink" title="1.1 interrupt"></a>1.1 interrupt</h3><p>如下方法会让线程进入BLOCKED(阻塞)状态，调用interrupt方法会打断阻塞。</p><ul><li>Object的wait方法</li><li>Object的wait(long)方法</li><li>Object的wait(long, int)方法</li><li>Thread的sleep(long)方法</li><li>Thread的sleep(long, int)方法</li><li>Thread的join方法</li><li>Thread的join(long)方法</li><li>Thread的join(long, int)方法</li><li>InterruptibleChannel的io操作</li><li>Selector的wackup方法</li></ul><p>上诉方法会让线程进入BLOCKED状态，其他线程调用该线程的interrupt方法，会打断这种阻塞。因此上诉方法被称为可<strong>中断方法</strong>。<br><strong><em>注意:打断一个线程并不意味着线程生命周期结束，仅仅是打断线程的阻塞状态。</em></strong></p><p>如果你在如下线程sleep期间打断该线程，你会捕获到InterruptedException异常，并输出相关内容:</p><pre><code>Thread thread = new Thread(() -&gt; {    try{        TimeUnit.MINUTES.sleep(1);    } catch (InterruptedException e) {        System.out.println(&quot;Oh, i am be interrupted.&quot;);    }});</code></pre><p>输出内容:</p><pre><code>Oh, i am be interrupted.</code></pre><p>在一个线程内部，存在着一个interrupt flag标识，如果一个线程被interrupt，那么它的interrupt标识将被设置。但如果线程处于中断方法中，中断导致的InterruptedException异常被捕获，会导致flag被清除。注意:一个已经死亡的线程，对其的interrupt会被直接忽略。</p><h3 id="1-2-isInterrupted"><a href="#1-2-isInterrupted" class="headerlink" title="1.2 isInterrupted"></a>1.2 isInterrupted</h3><p>isInterrupted方法主要用于判断线程是否被中断，该方法仅对interrupt标识进行判断，不会导致标识发生任何改变，而即将介绍的interrupted则不然。</p><p>下面我们来做个对比，对没有进入阻塞状态的线程和进入阻塞状态的线程分别调用interrupt方法，对于后者捕获InterruptedException异常，然后查看他们的中断状态。</p><p>不进入阻塞状态的线程如下:</p><pre><code>Thread thread = new Thread(() -&gt; {    while(true){        // do nothing,just empty loop.    }});thread.start();Sytem.out.printf(&quot;线程被中断了吗? %s \n&quot;, thread.isInterrupted());thread.interrupt();Sytem.out.printf(&quot;线程被中断了吗? %s \n&quot;, thread.isInterrupted());</code></pre><p>上诉代码输出结果如下:</p><pre><code>线程被中断了吗? false线程被中断了吗? true</code></pre><p>进入阻塞状态，并捕获InterruptedException异常的线程如下:</p><pre><code>Thread thread = new Thread(() -&gt; {    while(true){        try{            TimeUnit.MINUTES.sleep(1);        } catch (InterruptedException e) {            System.out.printf(&quot;我被中断了吗? %s \n&quot;, isInterrupted());        }    }});thread.start();Sytem.out.printf(&quot;线程被中断了吗? %s \n&quot;, thread.isInterrupted());thread.interrupt();Sytem.out.printf(&quot;线程被中断了吗? %s \n&quot;, thread.isInterrupted());</code></pre><p>上诉代码输出结果如下:</p><pre><code>线程被中断了吗? false我被中断了吗? false线程被中断了吗? false</code></pre><h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h3><p>interrupted是一个静态方法，虽然它也用于判断当前线程是否被中断。但它在判断线程中断状态后会擦除线程的interrupt标识。也就是说，如果线程被打断了，那么第一次调用interrupt方法会返回true，此后均返回false。</p><p>其调用方式如下:</p><pre><code>Thread thread = new Thread(() -&gt; {    while(true){        Thread.interrupted();    }});thread.start()thread.interrupt();</code></pre><h2 id="二、如何正确关闭一个线程"><a href="#二、如何正确关闭一个线程" class="headerlink" title="二、如何正确关闭一个线程"></a>二、如何正确关闭一个线程</h2><p>JDK有一个Deprecated方法stop，但该方法存在一个问题，JDK官方早已不推荐使用，其在后续版本有可能被移除。该方法在关闭线程时，有可能不会释放monitor锁，所以强烈建议不要使用stop方法结束线程，本节主要介绍几种关闭线程的方法。</p><h3 id="2-1-正常关闭"><a href="#2-1-正常关闭" class="headerlink" title="2.1 正常关闭"></a>2.1 正常关闭</h3><h4 id="2-1-1-线程结束生命周期正常结束"><a href="#2-1-1-线程结束生命周期正常结束" class="headerlink" title="2.1.1 线程结束生命周期正常结束"></a>2.1.1 线程结束生命周期正常结束</h4><p>线程运行结束，完成了自己的使命，会正常退出，如果线程的任务耗时较短，或者时间可控。就可以放任它正常结束。</p><h4 id="2-1-2-捕获中断信号关闭线程"><a href="#2-1-2-捕获中断信号关闭线程" class="headerlink" title="2.1.2 捕获中断信号关闭线程"></a>2.1.2 捕获中断信号关闭线程</h4><p>我们通过new Thread的方式创建线程，看似简单，其实它派生的成本是比较高的，为了节省开销，一个线程往往循环的执行某个任务，如心跳检查，不断地接收网络报文等，决定退出时，可以借助中断线程的方式退出:</p><pre><code>Thread thread = new Thread(() -&gt; {    while(isInterrupted()){        // do something    }    System.out.println(&quot;I will be exiting.&quot;)});thread.start()thread.interrupt();</code></pre><p>上诉代码是通过判断interrupt标识来退出，如果线程正处于中断状态，可以通过捕获中断信号来退出:</p><pre><code>Thread thread = new Thread(() -&gt; {    while(isInterrupted()){        // do something        try{            TimeUnit.MINUTES.sleep(1);        } catch (InterruptedException e) {            break;        }    }    System.out.println(&quot;I will be exiting.&quot;)});thread.start()thread.interrupt();</code></pre><h4 id="2-1-3-使用volatile开关控制"><a href="#2-1-3-使用volatile开关控制" class="headerlink" title="2.1.3 使用volatile开关控制"></a>2.1.3 使用volatile开关控制</h4><p>如果担心interrupt标识被擦除，且逻辑单元中不会执行任何可中断方法，则可以使用volatile修饰的开关flag关闭线程：</p><pre><code>static class MyTask extends Thread {    private volatile boolean closed = false;    @Override    public void run() {        while(!closed &amp;&amp; !isInterrupted()){            // do something        }        System.out.println(&quot;I will be exiting.&quot;)    }    public void close() {        this.closed = true;        this.interrupt();    }}public static void main(String args[]) {    MyTask task = new MyTask();    task.start();    task.close();}</code></pre><h3 id="2-2-异常退出"><a href="#2-2-异常退出" class="headerlink" title="2.2 异常退出"></a>2.2 异常退出</h3><p>在线程的执行单元中，是不允许抛出checked异常的，如果线程在运行过程中需要捕获checked异常，并因此决定是否还要继续运行。那么此时可以将checked异常封装成unchecked异常(RuntimeException)抛出进而结束线程的生命周期。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> interrupt </tag>
            
            <tag> interrupted </tag>
            
            <tag> 关闭线程 </tag>
            
            <tag> volatile </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程基础（六）-线程sleep和yield</title>
      <link href="/2020/01/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89-%E7%BA%BF%E7%A8%8Bsleep%E5%92%8Cyield/"/>
      <url>/2020/01/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89-%E7%BA%BF%E7%A8%8Bsleep%E5%92%8Cyield/</url>
      
        <content type="html"><![CDATA[<h2 id="一、sleep方法"><a href="#一、sleep方法" class="headerlink" title="一、sleep方法"></a>一、sleep方法</h2><h3 id="1-1-sleep方法介绍"><a href="#1-1-sleep方法介绍" class="headerlink" title="1.1 sleep方法介绍"></a>1.1 sleep方法介绍</h3><p>线程的sleep方法，会让线程进入指定时间的休眠，期间不会放弃monitor锁的所有权（在以后关于线程同步和锁的文章中会重点介绍monitor锁）。线程调用sleep方法后，会由RUNNING状态转变为BLOCK状态，休眠了指定时间后再进入RUNNABLE状态。</p><p>调用sleep方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前线程休眠2毫秒</span><br><span class="line">Thread.sleep(2)</span><br></pre></td></tr></table></figure><p>sleep的两个重载方法如下：</p><ul><li>public static void sleep(long millis) throws InterruptedException</li><li>public static void sleep(long millis,int nanos) throws InterruptedException</li></ul><p>第一个方法执行指定毫秒数的休眠，第二个方法执行指定毫秒数和纳秒数的休眠。</p><h3 id="1-2-使用TimeUnit代替Thread-sleep"><a href="#1-2-使用TimeUnit代替Thread-sleep" class="headerlink" title="1.2 使用TimeUnit代替Thread.sleep"></a>1.2 使用TimeUnit代替Thread.sleep</h3><p>在JDK1.5版本后，java引入了一个枚举类TimeUnit，对sleep方法进行了很好的封装。使用它可以省去时间单位的换算。使代码更加清晰，使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(2 * 1000);</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其他还有</span><br><span class="line">TimeUnit.HOURS.sleep(2);</span><br><span class="line">TimeUnit.MINUTES.sleep(2);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(2);</span><br></pre></td></tr></table></figure><h2 id="二、yield方法"><a href="#二、yield方法" class="headerlink" title="二、yield方法"></a>二、yield方法</h2><p>yield方法属于启发式方法，它会提醒调度器我愿意放弃当前的CPU资源，如果CPU资源不紧张，这种提醒可能被忽略。<br>当这种提醒没被忽略时，线程会从RUNNING状态转变为RUNNABLE状态，它同样不会释放锁。但yield不是一个常用的方法，因为它主动告诉调度器愿意放弃属于自己的资源，但这仅仅是一个提示（hint），CPU调度器不能担保每次都能满足yield提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadYield &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IntStream.range(0, 2)</span><br><span class="line">                .mapToObj(ThreadYield::create)</span><br><span class="line">                .forEach(Thread::start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Thread create(int index) &#123;</span><br><span class="line">        return new Thread(() -&gt; &#123;</span><br><span class="line">            if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上诉程序，会发现有时出现0，1有时出现1，0，有时只会出现1。</p><h2 id="三、sleep方法和yield方法的异同"><a href="#三、sleep方法和yield方法的异同" class="headerlink" title="三、sleep方法和yield方法的异同"></a>三、sleep方法和yield方法的异同</h2><p>在JDK1.5之前，yield方法实际上是调用了sleep(0)，但实际上存在本质的区别:</p><ul><li>sleep会使线程block，会在block指定时间后释放CPU资源</li><li>yield会使线程直接进入RUNNABLE状态，立即释放资源(如果CPU调度器没有忽略这个提示的话)</li><li>sleep几乎百分之百的完成给定时间的休眠，yield的提示不一定被响应</li><li>sleep中的线程被其他线程调用interrupt会捕获中断信号，yield不会。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> sleep </tag>
            
            <tag> yield </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（五）-守护线程</title>
      <link href="/2020/01/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>守护线程是一类比较特殊的线程，一般用于处理一些后台工作，比如java垃圾回收线程。</p><h3 id="在什么时候需要用到守护线程"><a href="#在什么时候需要用到守护线程" class="headerlink" title="在什么时候需要用到守护线程"></a>在什么时候需要用到守护线程</h3><p>要回答上诉问题，首先要知道，一个JVM程序在什么时候退出？正常情况下，JVM没有一个非守护线程，JVM的进程会退出。</p><p>也就是说，守护线程具有自动结束生命周期的特性，当你希望在程序退出时或退出后做一些工作可以用到守护线程，试想java垃圾回收进程是一个非守护进程，当main方法执行完成后，程序仍无法退出。</p><h3 id="将java线程指定为守护线程"><a href="#将java线程指定为守护线程" class="headerlink" title="将java线程指定为守护线程"></a>将java线程指定为守护线程</h3><p>设置守护线程的方法非常简单，使用setDaemon(true)设置即可,注意setDaemon在线程启动前才生效，如果一个线程已经死亡，再设置setDaemon会报IllegalThreadStateException:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; true为守护线程，false为非守护线程</span><br><span class="line">thread.setDaemon(true);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="判断一个线程是否为守护线程"><a href="#判断一个线程是否为守护线程" class="headerlink" title="判断一个线程是否为守护线程"></a>判断一个线程是否为守护线程</h3><p>判断一个线程是否为守护线程，可以使用isDaemon()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.isDaemon()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 守护线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（四）-jvm内存结构</title>
      <link href="/2020/01/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>线程和栈内存关系密切，为了更好的理解线程，有必要了解一下JVM的内存分布机制。但是在本节不会过度深入的讲解JVM的原理和内存，只会向大家介绍一下JVM的内存分布及各个内存区域的作用，在了解各个内存区域的作用时，请不要从该区域的名称推测该区域的作用，容易被名称弄混淆。</p><h2 id="一、JVM内存结构"><a href="#一、JVM内存结构" class="headerlink" title="一、JVM内存结构"></a>一、JVM内存结构</h2><p>JVM在执行程序的过程中会将物理内存划分为不同内存区域，以存放不同的数据。有些在JVM启动时创建，有些在程序运行时才创建，比如虚拟机栈，JVM内存区域如下图所示:<br><img src="/img/thread/jvm_memory_structure.png" alt=""><br>从上图我们可以得知，JVM将内存分为五个区域，分别是堆内存、方法区、虚拟机栈、本地方法栈和程序计数器。其中堆内存和方法区是所有线程所共享的区域，虚拟机栈、本地方法栈和程序计数器为线程私有，下面我们来了解每个区域的作用：</p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>所有的程序，都需要操作系统通过控制总线向CPU发送机器指令，程序计数器在jvm中的作用就是用来存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。由于一个处理器在某一时刻只执行一个线程中的机器指令，为了在CPU时间片轮转切换上下文后顺利回到正确执行位置，每个线程都需要具有一个独立的程序计数器，因此程序计数器被设计为了每个线程私有。</p><h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><p>java虚拟机栈与线程密切相关，它是线程私有的，在程序运行时被创建。在线程中，每一个方法的执行都会创建一个名为栈帧（stack frame）的数据结构，主要存放局部变量表、操作栈、动态链接、方法返回地址等，如下图所示:<br><img src="/img/thread/jvm_vm_stack.png" alt=""><br>每一个线程在创建时，JVM都会为其创建一个虚拟机栈，虚拟机栈的大小可以由-xss来配置，方法的调用其实就是栈帧压入和弹出的过程。同等大小的虚拟机栈，如果局部变量表的大小越小，可压入的栈帧就越多，意味着可递归调用方法就越多，反之亦然。一般将栈帧的内存大小叫做宽度，虚拟机栈的大小称为深度。</p><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>Java提供了调用本地方法的接口（Java Native Interface）,也就是调用C/C++程序的接口，比如网络通信、文件操作的底层等都是JNI方法，JVM提供的本地方法栈就是用来存放本地方法的内存区域。本地方法栈同样时线程私有的内存区域。</p><h3 id="4、堆内存"><a href="#4、堆内存" class="headerlink" title="4、堆内存"></a>4、堆内存</h3><p>堆内存是JVM中最大的一块内存区域，被所有线程共享，几乎java运行时创建的所有对象实例都存放在该区域。由于内存最大，也是java垃圾回收的主要区域，因此也被称为“GC堆”。<br><img src="/img/thread/jvm_heap.png" alt=""><br>如上图所示，堆内存被细分为新生代、老年代(Tenured)。更细致的被分为:Eden区、From Survivor区(s0)、To Survivor区(s1)。每个区域的作用可以在java的垃圾回收机制即GC机制中详细的了解，这里不进行展开。</p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p>方法区也是线程所共享的区域，该区域主要用于存放被JVM加载的类信息、常量、静态变量、即时编译器编译的代码等数据。由于方法区与堆内存有很多共性:线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出OutOfMemoryError异常。该区域被java虚拟机规范划分为堆内存的一个逻辑分区，但它实际是与堆内存分开的，经常被称为“非堆”。<br><img src="/img/thread/jvm_method_area.png" alt=""></p><h4 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h4><p>当一个没有使用静态变量的工具类，在调用它的静态方法时需要考虑线程安全问题吗？</p><h2 id="二、确定可创建线程的数量"><a href="#二、确定可创建线程的数量" class="headerlink" title="二、确定可创建线程的数量"></a>二、确定可创建线程的数量</h2><p>我们简单了解了JVM的内存结构，其中程序计数器是比较小的一块内存，该部分不会出现任何溢出异常。与线程创建关系比较大的是虚拟机栈内存，而且栈内存的划分直接决定在一个jvm进程中能创建的线程数量。</p><p>指定栈内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss128k</span><br></pre></td></tr></table></figure><p>指定初始堆大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms64m</span><br></pre></td></tr></table></figure><p>指定最大堆大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx216m</span><br></pre></td></tr></table></figure><p>查看JVM默认栈内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; linux 使用如下命令</span><br><span class="line">java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</span><br><span class="line">&#x2F;&#x2F; windows 使用如下命令</span><br><span class="line">java -XX:+PrintFlagsFinal -version | findstr &quot;ThreadStackSize&quot;</span><br></pre></td></tr></table></figure><p>线程的数量精确计算公式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数量&#x3D;(最大寻址空间(MaxProcessMemory) - JVM堆内存 - ReservedOsMemory)&#x2F;ThreadStackSize(Xss)</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>最大寻址空间:由操作系统决定，win32的系统约为2G多一点</li><li>ReservedOsMemory：为系统保留内存，大多为136M</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> java内存结构 </tag>
            
            <tag> 程序计数器 </tag>
            
            <tag> 虚拟机栈 </tag>
            
            <tag> 本地方法栈 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（三）-线程的父子关系与线程的分组</title>
      <link href="/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%BB%84/"/>
      <url>/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、线程的父子关系"><a href="#1、线程的父子关系" class="headerlink" title="1、线程的父子关系"></a>1、线程的父子关系</h2><p>java中，一个线程的父线程是指创建它的线程，实际上，在jvm中的线程都是平级的，父线程仅仅是创建子线程的线程，父线程的生命周期与子线程是无关的——即父线程死后子线程任然可以运行。<br>jvm仅仅是在父子线程之间轮换，以保证每个线程能享有cpu资源。我们可以通过如下代码发现，父线程死后，子线程仍在运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadParent extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        new Child().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadParent threadParent &#x3D; new ThreadParent();</span><br><span class="line">        threadParent.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        threadParent.interrupt();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;Parent thread is alive? &quot; + threadParent.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;我还活着&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">Parent thread is alive? false</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br></pre></td></tr></table></figure><h2 id="2、线程的分组"><a href="#2、线程的分组" class="headerlink" title="2、线程的分组"></a>2、线程的分组</h2><p>Thread的构造函数中，可以显示的指定线程的分组，也就是ThreadGroup。如果在创建线程的时候没有显示的指定线程的分组，那么该线程会被加入到父线程所在的分组。</p><p>可以通过如下方式指定线程的分组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup myGroup &#x3D; new ThreadGroup(&quot;MyGroup&quot;);</span><br><span class="line">Thread myGroupThread &#x3D; new Thread(myGroup, &quot;myGroupThread&quot;);</span><br></pre></td></tr></table></figure><p>如果要获取一个线程的分组可以使用如下方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup();</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">myGroupThread.getThreadGroup();</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadGroup myGroup &#x3D; new ThreadGroup(&quot;MyGroup&quot;);</span><br><span class="line">    Thread myGroupThread &#x3D; new Thread(myGroup, &quot;myGroupThread&quot;);</span><br><span class="line"></span><br><span class="line">    Thread notSpecifiedGroupThread &#x3D; new Thread(&quot;notSpecifiedGroupThread&quot;);</span><br><span class="line">    ThreadGroup mainGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Main thread belong group: &quot; + mainGroup.getName());</span><br><span class="line">    System.out.println(&quot;Group not specified Thread belong group: &quot; + notSpecifiedGroupThread.getThreadGroup().getName());</span><br><span class="line">    System.out.println(&quot;My Group thread belong group: &quot; + myGroupThread.getThreadGroup().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main thread belong group: main</span><br><span class="line">Group not specified Thread belong group: main</span><br><span class="line">My Group thread belong group: MyGroup</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 线程 </tag>
            
            <tag> 父子关系 </tag>
            
            <tag> 分组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（二）-线程的命名</title>
      <link href="/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/"/>
      <url>/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在java中，每个线程都有自己的名字，在构建线程时为其取一个有意义的名字是一种比较好的做法，特别是在线程特别多的程序中，这样方便问题的排查和跟踪。</p><h2 id="1、线程的默认命名"><a href="#1、线程的默认命名" class="headerlink" title="1、线程的默认命名"></a>1、线程的默认命名</h2><p>如果没有显示的为线程指定一个名字，线程会有一个以”Thread-“为前缀，以一个自增的数字为后缀的名字。这个自增的数字在整个jvm中不断自增,如果我们执行以下代码将会看到线程默认命名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    IntStream.range(0, 5).boxed().map(i -&gt; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName())</span><br><span class="line">    )).forEach(Thread::start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">Thread-1</span><br><span class="line">Thread-4</span><br><span class="line">Thread-2</span><br><span class="line">Thread-3</span><br></pre></td></tr></table></figure><h2 id="2、使用构造方法命名线程"><a href="#2、使用构造方法命名线程" class="headerlink" title="2、使用构造方法命名线程"></a>2、使用构造方法命名线程</h2><p>java提供了很多Thread的构造方法，其中大部分可以对线程进行命名，具体如下:</p><ul><li>Thread(String name)</li><li>Thread(Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</li></ul><p>我们尝试用第二个构造方法对线程进行命名，并输出命名后线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadName &#123;</span><br><span class="line">    public final static String PREFIX &#x3D; &quot;FINE-&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IntStream.range(0, 5).boxed().map(ThreadName::createThread)</span><br><span class="line">                .forEach(Thread::start);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Thread createThread(final int intName) &#123;</span><br><span class="line">        return new Thread(</span><br><span class="line">                () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">                PREFIX + intName</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们对线程使用了新名字，以”FINE-“开头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FINE-0</span><br><span class="line">FINE-2</span><br><span class="line">FINE-1</span><br><span class="line">FINE-3</span><br><span class="line">FINE-4</span><br></pre></td></tr></table></figure><h2 id="3、修改线程的名字"><a href="#3、修改线程的名字" class="headerlink" title="3、修改线程的名字"></a>3、修改线程的名字</h2><p>不论你使用线程默认的名字，还是使用构造函数自定义了线程的名字，在启动线程之前，还有一次修改线程名字的机会，线程一旦启动，名字将不再被修改，可以使用线程的setName方法修改线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread namedThread &#x3D; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">        &quot;ConstructorName&quot;</span><br><span class="line">    );</span><br><span class="line">    namedThread.setName(&quot;SetName&quot;);</span><br><span class="line">    namedThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，最终线程的名字为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetName</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 线程命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在java进程中创建、启动线程并使用jconsole观察线程</title>
      <link href="/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在java中，创建线程主要有两种方式，一是通过继承Thread类，二是通过实现Runnable接口。但严格地说，在java JDK中，能够代表线程的只有Thread类，请大家思考Runnable接口又是如何运作的呢？我们将在后续揭晓。</p><h1 id="一、使用Thread类创建线程"><a href="#一、使用Thread类创建线程" class="headerlink" title="一、使用Thread类创建线程"></a>一、使用Thread类创建线程</h1><p>使用继承Thread类创建线程的方式非常简单，只需要继承Thread类，然后重写Thread类的run方法，在run方法中实现自己的业务逻辑即可，下面我们就来创建并运行一个java线程。</p><p>这个多线程程序模仿在看新闻的同时听听音乐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                playMusic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void playMusic()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;play music&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void readNews()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;read news&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序会不断的交替看新闻和听音乐，如果使用java8 Lambda表达式，代码看起来会更加简洁。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(Main::playMusic).start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-Thread模拟银行大厅的叫号系统"><a href="#1-1-Thread模拟银行大厅的叫号系统" class="headerlink" title="1.1 Thread模拟银行大厅的叫号系统"></a>1.1 Thread模拟银行大厅的叫号系统</h3><p>学习了使用Thread类创建线程，那我们使用Thread类来模拟一下银行大厅的叫号系统吧</p><p>相信很多人都去过银行办理业务吧，当你走进银行，需要先领取一张流水号纸票，然后拿着纸票在坐在休息区等待你的号码显示在业务办理的橱窗显示器上面，如下图所示:<br><img src="/img/thread/bank_stream.png" alt=""><br>假设银行大厅共有4台出号机，限定当天受理50笔业务，意味着号码最多只能出到50。<br>TicketProducer代表大厅的出号机，代码如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducer extends Thread &#123;</span><br><span class="line">    &#x2F;&#x2F; 柜台名称</span><br><span class="line">    public final String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    public TicketProducer(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(&quot;柜台：&quot; + name + &quot;当前受理号码是&quot; + index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写一个main函数对其进行测试，定义4个TicketProducer线程，并且分别行动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new TicketProducer(&quot;1号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;2号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;3号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;4号柜台&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后结果大失所望，怎么每个线程都是从1到50呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是1</span><br><span class="line">柜台：2号柜台当前受理号码是1</span><br><span class="line">柜台：1号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是2</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>出现这个问题，根本原因是每个线程的逻辑执行单元都不一样。创建了4个TicketProducer线程，他们的票号都是从1到50，并没有获取唯一一个递增的票号。那么应该怎么改进呢？很容易想到，无论初始化多少个TicketProducer线程，只需要保证index唯一即可，我们会立即想到使用static修饰index的方式，这样可以吗？让我们试试，改进后的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是3</span><br><span class="line">柜台：1号柜台当前受理号码是4</span><br><span class="line">柜台：2号柜台当前受理号码是5</span><br><span class="line">柜台：1号柜台当前受理号码是6</span><br><span class="line">柜台：3号柜台当前受理号码是7</span><br><span class="line">柜台：2号柜台当前受理号码是8</span><br><span class="line">柜台：1号柜台当前受理号码是9</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过对index进行static修饰，看起来满足了我们的需求，但共享资源被多个线程进行读写操作时很容易出现线程安全问题，这里的(index++)实际上对index变量进行了读、更改和写操作，所以当多尝试几次，便会出现多个线程处理同号纸票或者某些号不会出现甚至大于Max的情况。况且这里只有一个index共享资源，如果共享资源很多呢？不可能都用static修饰，而且static修饰的变量生命周期很长，所以java提供了一个接口Runnable专门用于处理该问题，将线程的控制和业务逻辑彻底分离开。（使用Runnable接口仍会有线程安全问题）</p><h1 id="二、使用Runnable接口创建线程"><a href="#二、使用Runnable接口创建线程" class="headerlink" title="二、使用Runnable接口创建线程"></a>二、使用Runnable接口创建线程</h1><p>我们说使用static修饰index这个共享资源不是一个好方式，那么我们使用Runnable接口实现逻辑执行单元，重构一下银行大厅叫号系统吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducerRunnable implements Runnable &#123;</span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数,不做static修饰</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; 的号码是&quot; + index++);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始行动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TicketProducerRunnable ticketProducerRunnable &#x3D; new TicketProducerRunnable();</span><br><span class="line"></span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;1号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;2号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;3号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;4号柜台&quot;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序输出和使用static修饰index效果是一样的，仍然会有线程安全问题，因为他们的资源都是共享的，但不会再出现每一个叫号机从1打印到50的情况，而且变量的生命周期可以随线程的结束而结束。</p><h1 id="三、使用Jconsole观察线程"><a href="#三、使用Jconsole观察线程" class="headerlink" title="三、使用Jconsole观察线程"></a>三、使用Jconsole观察线程</h1><p>从java5开始，JDK中引入了Jconsole以观察线程，进行性能分析。让我们来试试使用Jconsole观察一下我们程序的线程有多少个吧。</p><h3 id="3-1-启动Jconsole"><a href="#3-1-启动Jconsole" class="headerlink" title="3.1 启动Jconsole"></a>3.1 启动Jconsole</h3><p>找到JDK安装路径的bin目录，双击运行jconsole.exe<br><img src="/img/thread/jconsole_start.png" alt=""><br>选择我们要查看的本地线程，这里是TicketProducerRunnable<br><img src="/img/thread/jconsole_thread.png" alt=""><br>可以看到除了我们创建的1号、2号、3号、4号线程外，还有其他线程，这是jvm启动时创建的许多线程。<br>同样可以使用性能分析工具jstack观察线程，jstack可以分析线程的堆栈使用情况，后续会做详细解释。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> Runnable </tag>
            
            <tag> Jconsole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（一）--认识线程</title>
      <link href="/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;想必大家都有过这样的体验，在聊天的时候听听音乐，在创作的时候查查资料，这就是我们常说的并行。在计算机的世界里，并行实际上是指，一系列任务在计算机中同时运行。在单核CPU中并没有真正的并行，它只不过是CPU时间钟带给你的错觉。但在多核CPU计算机中，真正的并行还是存在的。</p><h1 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h1><p>&ensp;&ensp;&ensp;&ensp;如今的操作系统大多都支持多任务的执行，对于计算机而言，一个任务就是一个进程(Process),在每一个进程内部至少要有一个线程(Thread)是在运行中，有时线程也称为轻量级进程。<br>&ensp;&ensp;&ensp;&ensp;线程是程序执行的最小单元，每个线程都有自己的局部变量表，程序计数器（指向正在执行的指令指针）以及各自的生命周期。<br>&ensp;&ensp;&ensp;&ensp;那么在java中如何创建线程呢，如果你还不太清楚可以看我另外一篇文章<a href="https://xiongdi-blog.github.io/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/">在java进程中创建线程并使用jconsole观察线程</a></p><h1 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a>二、线程的生命周期</h1><p>&ensp;&ensp;&ensp;&ensp;前面提到过，每个线程都有自己的局部变量表，程序计数器和生命周期。线程的生命周期描述了线程从创建到死亡的过程。<br>&ensp;&ensp;&ensp;&ensp;请大家思考，执行了线程的start方法就代表该线程开始执行了吗？<br><img src="/img/thread/thread_life.png" alt=""><br>&ensp;&ensp;&ensp;&ensp;由上图可知：线程的生命周期大体分为五个阶段</p><ul><li>NEW：创建</li><li>RUNNABLE: 可执行状态</li><li>RUNNING：执行状态</li><li>BLOCKED：阻塞状态</li><li>TERMINALTED：结束状态</li></ul><p>&ensp;&ensp;&ensp;&ensp;线程从NEW切换为RUNNABLE只需要程序执行start方法，线程一经启动就可以立即得到执行吗？答案是否定的，线程的运行与否和进程一样都要听命于CPU的调度。</p><ul><li>当RUNNABLE状态的线程被cpu选中，从而进入了RUNNING状态</li><li>当RUNNING状态的线程由于CPU的调度轮询放弃执行、或者线程主动调用yield方法放弃CPU执行权。线程进入RUNNABLE状态</li><li>当RUNNING状态的线程调用wait、sleep或获取锁资源时，线程进入BLOCKED状态</li><li>当BLOCKED状态的线程被其他线程调用notify/notifyall唤醒、获取到了某个锁资源、、完成了指定时间的休眠或在阻塞过程中被其他线程调用interrupt方法打断，线程进入RUNNABLE状态</li><li>当线程调用了JDK已经不推荐使用的stop方法，意外死亡（JVM Crash），或者正常结束，线程直接进入TERMINALTED状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初遇SpringBoot</title>
      <link href="/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/"/>
      <url>/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="初遇SpringBoot"><a href="#初遇SpringBoot" class="headerlink" title="初遇SpringBoot"></a>初遇SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot是一个简化Spring开发的框架。用来监护spring应用开发，约定大于配置，去繁就简，just run 就能创建一个独立的，产品级的应用。</p><p>我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="1-快速创建"><a href="#1-快速创建" class="headerlink" title="1. 快速创建"></a>1. 快速创建</h3><p>打开浏览器，访问<a href="https://start.spring.io/，进入如下页面" target="_blank" rel="noopener">https://start.spring.io/，进入如下页面</a></p><p><img src="C:%5CUsers%5Chz19084341%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200103154738139.png" alt="image-20200103154738139"></p><p>选择<strong>Project</strong>（项目类型）<strong>Language</strong>（语言）<strong>SpringBoot</strong>(SpringBoot版本)、<strong>Group</strong>（组/包名），<strong>Artifact</strong>（项目名）、<strong>Description</strong>（描述）、<strong>Package name</strong>（包名）<strong>Packaging</strong>（打包方式）、<strong>Java</strong>(Java版本)等信息点击下方“Generate”即可下载程序包。同时点击Explore可导出pom文件。也可以使用Idea快速创建。</p><p><img src="C:%5CUsers%5Chz19084341%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200103155033879.png" alt="image-20200103155033879"></p><h3 id="2-独立运行"><a href="#2-独立运行" class="headerlink" title="2. 独立运行"></a>2. 独立运行</h3><ul><li>spring-boot的启动方式主要有三种:<h5 id="1-运行带有main方法类"><a href="#1-运行带有main方法类" class="headerlink" title="1. 运行带有main方法类"></a>1. 运行带有main方法类</h5>这种方式很简单，我主要是通过idea的方式，进行执行。这种方式在启动的时候，会去自动加载classpath下的配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplicati@SpringBootApplicati public class DemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-通过命令行-java-jar-的方式"><a href="#2-通过命令行-java-jar-的方式" class="headerlink" title="2. 通过命令行 java -jar 的方式"></a>2. 通过命令行 java -jar 的方式</h5>执行：<br>java -jar jar_path –param<br>  jar_path: 指代将项目打包为jar打包之后的存储路径<br>  –param: 为需要在命令行指定的参数。例如:<br>java -jar jar_path –server.port=8081<br>可指定项目启动的端口号，该命令行参数，将会覆盖application.properties中的端口配置</li></ul><h5 id="3-通过spring-boot-plugin的方式"><a href="#3-通过spring-boot-plugin的方式" class="headerlink" title="3. 通过spring-boot-plugin的方式"></a>3. 通过spring-boot-plugin的方式</h5><p>如果需要正常使用该maven查件，需要我们在maven项目中增加以下插件配置:</p><pre><code>&lt;plugin&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;</code></pre><p>进入项目的根目录，执行:<br>mvn spring-boot:run -Drun.arguments=”–server.port=8888”<br>arguments：指定的参数，多个参数以”,”进行分割。</p><h3 id="3-主流框架集成"><a href="#3-主流框架集成" class="headerlink" title="3.主流框架集成"></a>3.主流框架集成</h3><h3 id="4-内嵌Servlet-可直接JAR运行"><a href="#4-内嵌Servlet-可直接JAR运行" class="headerlink" title="4. 内嵌Servlet,可直接JAR运行"></a>4. 内嵌Servlet,可直接JAR运行</h3><h3 id="5-自动配置"><a href="#5-自动配置" class="headerlink" title="5. 自动配置"></a>5. 自动配置</h3><h3 id="6-开箱即用，不需要配置繁琐的XML"><a href="#6-开箱即用，不需要配置繁琐的XML" class="headerlink" title="6. 开箱即用，不需要配置繁琐的XML"></a>6. 开箱即用，不需要配置繁琐的XML</h3><h3 id="7-环境区分"><a href="#7-环境区分" class="headerlink" title="7. 环境区分"></a>7. 环境区分</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown使用指南</title>
      <link href="/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown的六级标题"><a href="#markdown的六级标题" class="headerlink" title="markdown的六级标题"></a>markdown的六级标题</h1><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- 文本1+ 文本2* 文本3</code></pre><p>效果：</p><ul><li>文本1</li></ul><ul><li>文本2</li></ul><ul><li>文本3</li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><pre><code>1. 列表内容2. 列表内容3. 列表内容</code></pre><p>效果：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><pre><code>---***</code></pre><p>效果：</p><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><pre><code>[简书](http://www.jianshu.com)</code></pre><p>效果：</p><p><a href="http://www.jianshu.com" target="_blank" rel="noopener">简书</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><pre><code>&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。</code></pre><p>效果：</p><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</p></blockquote><h1 id="斜体、粗体及斜体加粗"><a href="#斜体、粗体及斜体加粗" class="headerlink" title="斜体、粗体及斜体加粗"></a>斜体、粗体及斜体加粗</h1><pre><code>*一盏灯*， 一片昏黄；**一简书**， ***一杯淡茶***。</code></pre><p>效果：</p><p><em>一盏灯</em>， 一片昏黄；<strong>一简书</strong>， <strong><em>一杯淡茶</em></strong>。</p><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><pre><code>~~一盏灯， 一片昏黄； 一简书， 一杯淡茶。~~</code></pre><p>效果：</p><p><del>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</del></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>```<br>第一段代码<br>第二段代码<br>第三段代码<br>```<br>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段代码</span><br><span class="line">第二段代码</span><br><span class="line">第三段代码</span><br></pre></td></tr></table></figure><h1 id="句内代码块"><a href="#句内代码块" class="headerlink" title="句内代码块"></a>句内代码块</h1><pre><code>`create database hero;`</code></pre><p>效果：</p><p><code>create database hero;</code></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><pre><code>![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |</code></pre><p>效果：</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
