<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程基础（四）-jvm内存结构</title>
      <link href="/2020/01/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>线程和栈内存关系密切，为了更好的理解线程，有必要了解一下JVM的内存分布机制。但是在本节不会过度深入的讲解JVM的原理和内存，只会向大家介绍一下JVM的内存分布及各个内存区域的作用，在了解各个内存区域的作用时，请不要从该区域的名称推测该区域的作用，容易被名称弄混淆。</p><h2 id="一、java内存结构"><a href="#一、java内存结构" class="headerlink" title="一、java内存结构"></a>一、java内存结构</h2><p>JVM在执行程序的过程中会将物理内存划分为不同内存区域，以存放不同的数据。有些在JVM启动时创建，有些在程序运行时才创建，比如虚拟机栈，JVM内存区域如下图所示:<br><img src="/img/thread/jvm_memory_structure.png" alt=""><br>从上图我们可以得知，JVM将内存分为五个区域，分别是堆内存、方法区、虚拟机栈、本地方法栈和程序计数器。其中堆内存和方法区是所有线程所共享的区域，虚拟机栈、本地方法栈和程序计数器为线程私有，下面我们来了解每个区域的作用：</p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>所有的程序，都需要操作系统通过控制总线向CPU发送机器指令，程序计数器在jvm中的作用就是用来存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。由于一个处理器在某一时刻只执行一个线程中的机器指令，为了在CPU时间片轮转切换上下文后顺利回到正确执行位置，每个线程都需要具有一个独立的程序计数器，因此程序计数器被设计为了每个线程私有。</p><h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><p>java虚拟机栈与线程密切相关，它是线程私有的，在程序运行时被创建。在线程中，每一个方法的执行都会创建一个名为栈帧（stack frame）的数据结构，主要存放局部变量表、操作栈、动态链接、方法返回地址等，如下图所示:<br><img src="/img/thread/jvm_vm_stack.png" alt=""><br>每一个线程在创建时，JVM都会为其创建一个虚拟机栈，虚拟机栈的大小可以由-xss来配置，方法的调用其实就是栈帧压入和弹出的过程。同等大小的虚拟机栈，如果局部变量表的大小越小，可压入的栈帧就越多，意味着可递归调用方法就越多，反之亦然。一般将栈帧的内存大小叫做宽度，虚拟机栈的大小称为深度。</p><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>Java提供了调用本地方法的接口（Java Native Interface）,也就是调用C/C++程序的接口，比如网络通信、文件操作的底层等都是JNI方法，JVM提供的本地方法栈就是用来存放本地方法的内存区域。本地方法栈同样时线程私有的内存区域。</p><h3 id="4、堆内存"><a href="#4、堆内存" class="headerlink" title="4、堆内存"></a>4、堆内存</h3><p>堆内存是JVM中最大的一块内存区域，被所有线程共享，几乎java运行时创建的所有对象实例都存放在该区域。由于内存最大，也是java垃圾回收的主要区域，因此也被称为“GC堆”。<br><img src="/img/thread/jvm_heap.png" alt=""><br>如上图所示，堆内存被细分为新生代、老年代(Tenured)。更细致的被分为:Eden区、From Survivor区(s0)、To Survivor区(s1)。每个区域的作用可以在java的垃圾回收机制即GC机制中详细的了解，这里不进行展开。</p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p>方法区也是线程所共享的区域，该区域主要用于存放被JVM加载的类信息、常量、静态变量、即时编译器编译的代码等数据。由于方法区与堆内存有很多共性:线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出OutOfMemoryError异常。该区域被java虚拟机规范划分为堆内存的一个逻辑分区，但它实际是与堆内存分开的，经常被称为“非堆”。<br><img src="/img/thread/jvm_method_area.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> java内存结构 </tag>
            
            <tag> 程序计数器 </tag>
            
            <tag> 虚拟机栈 </tag>
            
            <tag> 本地方法栈 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（三）-线程的父子关系与线程的分组</title>
      <link href="/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%BB%84/"/>
      <url>/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、线程的父子关系"><a href="#1、线程的父子关系" class="headerlink" title="1、线程的父子关系"></a>1、线程的父子关系</h2><p>java中，一个线程的父线程是指创建它的线程，实际上，在jvm中的线程都是平级的，父线程仅仅是创建子线程的线程，父线程的生命周期与子线程是无关的——即父线程死后子线程任然可以运行。<br>jvm仅仅是在父子线程之间轮换，以保证每个线程能享有cpu资源。我们可以通过如下代码发现，父线程死后，子线程仍在运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadParent extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        new Child().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadParent threadParent &#x3D; new ThreadParent();</span><br><span class="line">        threadParent.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        threadParent.interrupt();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;Parent thread is alive? &quot; + threadParent.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;我还活着&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br><span class="line">Parent thread is alive? false</span><br><span class="line">我还活着</span><br><span class="line">我还活着</span><br></pre></td></tr></table></figure><h2 id="2、线程的分组"><a href="#2、线程的分组" class="headerlink" title="2、线程的分组"></a>2、线程的分组</h2><p>Thread的构造函数中，可以显示的指定线程的分组，也就是ThreadGroup。如果在创建线程的时候没有显示的指定线程的分组，那么该线程会被加入到父线程所在的分组。</p><p>可以通过如下方式指定线程的分组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup myGroup &#x3D; new ThreadGroup(&quot;MyGroup&quot;);</span><br><span class="line">Thread myGroupThread &#x3D; new Thread(myGroup, &quot;myGroupThread&quot;);</span><br></pre></td></tr></table></figure><p>如果要获取一个线程的分组可以使用如下方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup();</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">myGroupThread.getThreadGroup();</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadGroup myGroup &#x3D; new ThreadGroup(&quot;MyGroup&quot;);</span><br><span class="line">    Thread myGroupThread &#x3D; new Thread(myGroup, &quot;myGroupThread&quot;);</span><br><span class="line"></span><br><span class="line">    Thread notSpecifiedGroupThread &#x3D; new Thread(&quot;notSpecifiedGroupThread&quot;);</span><br><span class="line">    ThreadGroup mainGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Main thread belong group: &quot; + mainGroup.getName());</span><br><span class="line">    System.out.println(&quot;Group not specified Thread belong group: &quot; + notSpecifiedGroupThread.getThreadGroup().getName());</span><br><span class="line">    System.out.println(&quot;My Group thread belong group: &quot; + myGroupThread.getThreadGroup().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main thread belong group: main</span><br><span class="line">Group not specified Thread belong group: main</span><br><span class="line">My Group thread belong group: MyGroup</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 父子关系 </tag>
            
            <tag> 分组 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（二）-线程的命名</title>
      <link href="/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/"/>
      <url>/2020/01/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在java中，每个线程都有自己的名字，在构建线程时为其取一个有意义的名字是一种比较好的做法，特别是在线程特别多的程序中，这样方便问题的排查和跟踪。</p><h2 id="1、线程的默认命名"><a href="#1、线程的默认命名" class="headerlink" title="1、线程的默认命名"></a>1、线程的默认命名</h2><p>如果没有显示的为线程指定一个名字，线程会有一个以”Thread-“为前缀，以一个自增的数字为后缀的名字。这个自增的数字在整个jvm中不断自增,如果我们执行以下代码将会看到线程默认命名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    IntStream.range(0, 5).boxed().map(i -&gt; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName())</span><br><span class="line">    )).forEach(Thread::start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">Thread-1</span><br><span class="line">Thread-4</span><br><span class="line">Thread-2</span><br><span class="line">Thread-3</span><br></pre></td></tr></table></figure><h2 id="2、使用构造方法命名线程"><a href="#2、使用构造方法命名线程" class="headerlink" title="2、使用构造方法命名线程"></a>2、使用构造方法命名线程</h2><p>java提供了很多Thread的构造方法，其中大部分可以对线程进行命名，具体如下:</p><ul><li>Thread(String name)</li><li>Thread(Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</li></ul><p>我们尝试用第二个构造方法对线程进行命名，并输出命名后线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadName &#123;</span><br><span class="line">    public final static String PREFIX &#x3D; &quot;FINE-&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IntStream.range(0, 5).boxed().map(ThreadName::createThread)</span><br><span class="line">                .forEach(Thread::start);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Thread createThread(final int intName) &#123;</span><br><span class="line">        return new Thread(</span><br><span class="line">                () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">                PREFIX + intName</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们对线程使用了新名字，以”FINE-“开头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FINE-0</span><br><span class="line">FINE-2</span><br><span class="line">FINE-1</span><br><span class="line">FINE-3</span><br><span class="line">FINE-4</span><br></pre></td></tr></table></figure><h2 id="3、修改线程的名字"><a href="#3、修改线程的名字" class="headerlink" title="3、修改线程的名字"></a>3、修改线程的名字</h2><p>不论你使用线程默认的名字，还是使用构造函数自定义了线程的名字，在启动线程之前，还有一次修改线程名字的机会，线程一旦启动，名字将不再被修改，可以使用线程的setName方法修改线程的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread namedThread &#x3D; new Thread(</span><br><span class="line">        () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">        &quot;ConstructorName&quot;</span><br><span class="line">    );</span><br><span class="line">    namedThread.setName(&quot;SetName&quot;);</span><br><span class="line">    namedThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，最终线程的名字为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetName</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> 线程命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在java进程中创建、启动线程并使用jconsole观察线程</title>
      <link href="/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在java中，创建线程主要有两种方式，一是通过继承Thread类，二是通过实现Runnable接口。但严格地说，在java JDK中，能够代表线程的只有Thread类，请大家思考Runnable接口又是如何运作的呢？我们将在后续揭晓。</p><h1 id="一、使用Thread类创建线程"><a href="#一、使用Thread类创建线程" class="headerlink" title="一、使用Thread类创建线程"></a>一、使用Thread类创建线程</h1><p>使用继承Thread类创建线程的方式非常简单，只需要继承Thread类，然后重写Thread类的run方法，在run方法中实现自己的业务逻辑即可，下面我们就来创建并运行一个java线程。</p><p>这个多线程程序模仿在看新闻的同时听听音乐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                playMusic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void playMusic()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;play music&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void readNews()&#123;</span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">        System.out.println(&quot;read news&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序会不断的交替看新闻和听音乐，如果使用java8 Lambda表达式，代码看起来会更加简洁。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(Main::playMusic).start();</span><br><span class="line">        readNews();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-Thread模拟银行大厅的叫号系统"><a href="#1-1-Thread模拟银行大厅的叫号系统" class="headerlink" title="1.1 Thread模拟银行大厅的叫号系统"></a>1.1 Thread模拟银行大厅的叫号系统</h3><p>学习了使用Thread类创建线程，那我们使用Thread类来模拟一下银行大厅的叫号系统吧</p><p>相信很多人都去过银行办理业务吧，当你走进银行，需要先领取一张流水号纸票，然后拿着纸票在坐在休息区等待你的号码显示在业务办理的橱窗显示器上面，如下图所示:<br><img src="/img/thread/bank_stream.png" alt=""><br>假设银行大厅共有4台出号机，限定当天受理50笔业务，意味着号码最多只能出到50。<br>TicketProducer代表大厅的出号机，代码如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducer extends Thread &#123;</span><br><span class="line">    &#x2F;&#x2F; 柜台名称</span><br><span class="line">    public final String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    public TicketProducer(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(&quot;柜台：&quot; + name + &quot;当前受理号码是&quot; + index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写一个main函数对其进行测试，定义4个TicketProducer线程，并且分别行动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new TicketProducer(&quot;1号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;2号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;3号柜台&quot;).start();</span><br><span class="line"></span><br><span class="line">    new TicketProducer(&quot;4号柜台&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后结果大失所望，怎么每个线程都是从1到50呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是1</span><br><span class="line">柜台：2号柜台当前受理号码是1</span><br><span class="line">柜台：1号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是2</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>出现这个问题，根本原因是每个线程的逻辑执行单元都不一样。创建了4个TicketProducer线程，他们的票号都是从1到50，并没有获取唯一一个递增的票号。那么应该怎么改进呢？很容易想到，无论初始化多少个TicketProducer线程，只需要保证index唯一即可，我们会立即想到使用static修饰index的方式，这样可以吗？让我们试试，改进后的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">柜台：1号柜台当前受理号码是1</span><br><span class="line">柜台：3号柜台当前受理号码是2</span><br><span class="line">柜台：2号柜台当前受理号码是3</span><br><span class="line">柜台：1号柜台当前受理号码是4</span><br><span class="line">柜台：2号柜台当前受理号码是5</span><br><span class="line">柜台：1号柜台当前受理号码是6</span><br><span class="line">柜台：3号柜台当前受理号码是7</span><br><span class="line">柜台：2号柜台当前受理号码是8</span><br><span class="line">柜台：1号柜台当前受理号码是9</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过对index进行static修饰，看起来满足了我们的需求，但共享资源被多个线程进行读写操作时很容易出现线程安全问题，这里的(index++)实际上对index变量进行了读、更改和写操作，所以当多尝试几次，便会出现多个线程处理同号纸票或者某些号不会出现甚至大于Max的情况。况且这里只有一个index共享资源，如果共享资源很多呢？不可能都用static修饰，而且static修饰的变量生命周期很长，所以java提供了一个接口Runnable专门用于处理该问题，将线程的控制和业务逻辑彻底分离开。（使用Runnable接口仍会有线程安全问题）</p><h1 id="二、使用Runnable接口创建线程"><a href="#二、使用Runnable接口创建线程" class="headerlink" title="二、使用Runnable接口创建线程"></a>二、使用Runnable接口创建线程</h1><p>我们说使用static修饰index这个共享资源不是一个好方式，那么我们使用Runnable接口实现逻辑执行单元，重构一下银行大厅叫号系统吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TicketProducerRunnable implements Runnable &#123;</span><br><span class="line">    &#x2F;&#x2F; 最多受理50笔业务</span><br><span class="line">    public static final int Max &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前受理到业务数,不做static修饰</span><br><span class="line">    private int index &#x3D; 1;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (index &lt; Max) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; 的号码是&quot; + index++);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始行动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TicketProducerRunnable ticketProducerRunnable &#x3D; new TicketProducerRunnable();</span><br><span class="line"></span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;1号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;2号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;3号柜台&quot;).start();</span><br><span class="line">    new Thread(ticketProducerRunnable, &quot;4号柜台&quot;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序输出和使用static修饰index效果是一样的，仍然会有线程安全问题，因为他们的资源都是共享的，但不会再出现每一个叫号机从1打印到50的情况，而且变量的生命周期可以随线程的结束而结束。</p><h1 id="三、使用Jconsole观察线程"><a href="#三、使用Jconsole观察线程" class="headerlink" title="三、使用Jconsole观察线程"></a>三、使用Jconsole观察线程</h1><p>从java5开始，JDK中引入了Jconsole以观察线程，进行性能分析。让我们来试试使用Jconsole观察一下我们程序的线程有多少个吧。</p><h3 id="3-1-启动Jconsole"><a href="#3-1-启动Jconsole" class="headerlink" title="3.1 启动Jconsole"></a>3.1 启动Jconsole</h3><p>找到JDK安装路径的bin目录，双击运行jconsole.exe<br><img src="/img/thread/jconsole_start.png" alt=""><br>选择我们要查看的本地线程，这里是TicketProducerRunnable<br><img src="/img/thread/jconsole_thread.png" alt=""><br>可以看到除了我们创建的1号、2号、3号、4号线程外，还有其他线程，这是jvm启动时创建的许多线程。<br>同样可以使用性能分析工具jstack观察线程，jstack可以分析线程的堆栈使用情况，后续会做详细解释。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Thread </tag>
            
            <tag> Runnable </tag>
            
            <tag> Jconsole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础（一）--认识线程</title>
      <link href="/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;想必大家都有过这样的体验，在聊天的时候听听音乐，在创作的时候查查资料，这就是我们常说的并行。在计算机的世界里，并行实际上是指，一系列任务在计算机中同时运行。在单核CPU中并没有真正的并行，它只不过是CPU时间钟带给你的错觉。但在多核CPU计算机中，真正的并行还是存在的。</p><h1 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h1><p>&ensp;&ensp;&ensp;&ensp;如今的操作系统大多都支持多任务的执行，对于计算机而言，一个任务就是一个进程(Process),在每一个进程内部至少要有一个线程(Thread)是在运行中，有时线程也称为轻量级进程。<br>&ensp;&ensp;&ensp;&ensp;线程是程序执行的最小单元，每个线程都有自己的局部变量表，程序计数器（指向正在执行的指令指针）以及各自的生命周期。<br>&ensp;&ensp;&ensp;&ensp;那么在java中如何创建线程呢，如果你还不太清楚可以看我另外一篇文章<a href="https://xiongdi-blog.github.io/2020/01/01/%E5%9C%A8java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8jconsole%E8%A7%82%E5%AF%9F%E7%BA%BF%E7%A8%8B/">在java进程中创建线程并使用jconsole观察线程</a></p><h1 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a>二、线程的生命周期</h1><p>&ensp;&ensp;&ensp;&ensp;前面提到过，每个线程都有自己的局部变量表，程序计数器和生命周期。线程的生命周期描述了线程从创建到死亡的过程。<br>&ensp;&ensp;&ensp;&ensp;请大家思考，执行了线程的start方法就代表该线程开始执行了吗？<br><img src="/img/thread/thread_life.png" alt=""><br>&ensp;&ensp;&ensp;&ensp;由上图可知：线程的生命周期大体分为五个阶段</p><ul><li>NEW：创建</li><li>RUNNABLE: 可执行状态</li><li>RUNNING：执行状态</li><li>BLOCKED：阻塞状态</li><li>TERMINALTED：结束状态</li></ul><p>&ensp;&ensp;&ensp;&ensp;线程从NEW切换为RUNNABLE只需要程序执行start方法，线程一经启动就可以立即得到执行吗？答案是否定的，线程的运行与否和进程一样都要听命于CPU的调度。</p><ul><li>当RUNNABLE状态的线程被cpu选中，从而进入了RUNNING状态</li><li>当RUNNING状态的线程由于CPU的调度轮询放弃执行、或者线程主动调用yield方法放弃CPU执行权。线程进入RUNNABLE状态</li><li>当RUNNING状态的线程调用wait、sleep或获取锁资源时，线程进入BLOCKED状态</li><li>当BLOCKED状态的线程被其他线程调用notify/notifyall唤醒、获取到了某个锁资源、、完成了指定时间的休眠或在阻塞过程中被其他线程调用interrupt方法打断，线程进入RUNNABLE状态</li><li>当线程调用了JDK已经不推荐使用的stop方法，意外死亡（JVM Crash），或者正常结束，线程直接进入TERMINALTED状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MultiThread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初遇SpringBoot</title>
      <link href="/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/"/>
      <url>/2019/12/20/%E5%88%9D%E9%81%87SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="初遇SpringBoot"><a href="#初遇SpringBoot" class="headerlink" title="初遇SpringBoot"></a>初遇SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot是一个简化Spring开发的框架。用来监护spring应用开发，约定大于配置，去繁就简，just run 就能创建一个独立的，产品级的应用。</p><p>我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="1-快速创建"><a href="#1-快速创建" class="headerlink" title="1. 快速创建"></a>1. 快速创建</h3><p>打开浏览器，访问<a href="https://start.spring.io/，进入如下页面" target="_blank" rel="noopener">https://start.spring.io/，进入如下页面</a></p><p><img src="C:%5CUsers%5Chz19084341%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200103154738139.png" alt="image-20200103154738139"></p><p>选择<strong>Project</strong>（项目类型）<strong>Language</strong>（语言）<strong>SpringBoot</strong>(SpringBoot版本)、<strong>Group</strong>（组/包名），<strong>Artifact</strong>（项目名）、<strong>Description</strong>（描述）、<strong>Package name</strong>（包名）<strong>Packaging</strong>（打包方式）、<strong>Java</strong>(Java版本)等信息点击下方“Generate”即可下载程序包。同时点击Explore可导出pom文件。也可以使用Idea快速创建。</p><p><img src="C:%5CUsers%5Chz19084341%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200103155033879.png" alt="image-20200103155033879"></p><h3 id="2-独立运行"><a href="#2-独立运行" class="headerlink" title="2. 独立运行"></a>2. 独立运行</h3><ul><li>spring-boot的启动方式主要有三种:<h5 id="1-运行带有main方法类"><a href="#1-运行带有main方法类" class="headerlink" title="1. 运行带有main方法类"></a>1. 运行带有main方法类</h5>这种方式很简单，我主要是通过idea的方式，进行执行。这种方式在启动的时候，会去自动加载classpath下的配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplicati@SpringBootApplicati public class DemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-通过命令行-java-jar-的方式"><a href="#2-通过命令行-java-jar-的方式" class="headerlink" title="2. 通过命令行 java -jar 的方式"></a>2. 通过命令行 java -jar 的方式</h5>执行：<br>java -jar jar_path –param<br>  jar_path: 指代将项目打包为jar打包之后的存储路径<br>  –param: 为需要在命令行指定的参数。例如:<br>java -jar jar_path –server.port=8081<br>可指定项目启动的端口号，该命令行参数，将会覆盖application.properties中的端口配置</li></ul><h5 id="3-通过spring-boot-plugin的方式"><a href="#3-通过spring-boot-plugin的方式" class="headerlink" title="3. 通过spring-boot-plugin的方式"></a>3. 通过spring-boot-plugin的方式</h5><p>如果需要正常使用该maven查件，需要我们在maven项目中增加以下插件配置:</p><pre><code>&lt;plugin&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;</code></pre><p>进入项目的根目录，执行:<br>mvn spring-boot:run -Drun.arguments=”–server.port=8888”<br>arguments：指定的参数，多个参数以”,”进行分割。</p><h3 id="3-主流框架集成"><a href="#3-主流框架集成" class="headerlink" title="3.主流框架集成"></a>3.主流框架集成</h3><h3 id="4-内嵌Servlet-可直接JAR运行"><a href="#4-内嵌Servlet-可直接JAR运行" class="headerlink" title="4. 内嵌Servlet,可直接JAR运行"></a>4. 内嵌Servlet,可直接JAR运行</h3><h3 id="5-自动配置"><a href="#5-自动配置" class="headerlink" title="5. 自动配置"></a>5. 自动配置</h3><h3 id="6-开箱即用，不需要配置繁琐的XML"><a href="#6-开箱即用，不需要配置繁琐的XML" class="headerlink" title="6. 开箱即用，不需要配置繁琐的XML"></a>6. 开箱即用，不需要配置繁琐的XML</h3><h3 id="7-环境区分"><a href="#7-环境区分" class="headerlink" title="7. 环境区分"></a>7. 环境区分</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown使用指南</title>
      <link href="/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/12/20/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown的六级标题"><a href="#markdown的六级标题" class="headerlink" title="markdown的六级标题"></a>markdown的六级标题</h1><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- 文本1+ 文本2* 文本3</code></pre><p>效果：</p><ul><li>文本1</li></ul><ul><li>文本2</li></ul><ul><li>文本3</li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><pre><code>1. 列表内容2. 列表内容3. 列表内容</code></pre><p>效果：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><pre><code>---***</code></pre><p>效果：</p><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><pre><code>[简书](http://www.jianshu.com)</code></pre><p>效果：</p><p><a href="http://www.jianshu.com" target="_blank" rel="noopener">简书</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><pre><code>&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。</code></pre><p>效果：</p><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</p></blockquote><h1 id="斜体、粗体及斜体加粗"><a href="#斜体、粗体及斜体加粗" class="headerlink" title="斜体、粗体及斜体加粗"></a>斜体、粗体及斜体加粗</h1><pre><code>*一盏灯*， 一片昏黄；**一简书**， ***一杯淡茶***。</code></pre><p>效果：</p><p><em>一盏灯</em>， 一片昏黄；<strong>一简书</strong>， <strong><em>一杯淡茶</em></strong>。</p><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><pre><code>~~一盏灯， 一片昏黄； 一简书， 一杯淡茶。~~</code></pre><p>效果：</p><p><del>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</del></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>```<br>第一段代码<br>第二段代码<br>第三段代码<br>```<br>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段代码</span><br><span class="line">第二段代码</span><br><span class="line">第三段代码</span><br></pre></td></tr></table></figure><h1 id="句内代码块"><a href="#句内代码块" class="headerlink" title="句内代码块"></a>句内代码块</h1><pre><code>`create database hero;`</code></pre><p>效果：</p><p><code>create database hero;</code></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><pre><code>![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |</code></pre><p>效果：</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
